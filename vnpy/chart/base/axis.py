"""
Every
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional, TypeVar

from PyQt5.QtCore import QPointF, QRectF, Qt
from PyQt5.QtGui import QColor, QFont, QPainter, QPalette, QPen

from .base import Alignment, DrawConfig, Orientation
from .data_source import CandleDataSource, DataSource

T = TypeVar("T")


class AxisBase(ABC):
    """
    overload method calling sequence:
    prepare_draw_axis()
    prepare_draw_grids()
    draw()
    prepare_draw_labels()
    draw_labels_()
    """

    def __init__(self, orientation: "Orientation"):
        self.orientation = orientation
        self.axis_visible: bool = True

        self.grid_drawer: Optional["GridDrawer"] = LineGridDrawer(self)
        self.grid_visible: bool = True

        self.label_drawer: Optional["LabelDrawer"] = None
        self.label_visible = True
        # spacing to plot_area: spacing-right for Vertical AxisBase, spacing-top for Horizontal
        self.label_spacing_to_plot_area: int = 2

    # @virtual
    def prepare_draw_axis(self, config: "DrawConfig", painter: "QPainter") -> None:
        pass

    # @virtual
    def prepare_draw_grids(self, config: "DrawConfig", painter: "QPainter") -> None:
        pass

    # @virtual
    def prepare_draw_labels(self, config: "DrawConfig", painter: "QPainter") -> None:
        pass

    def draw_grids(self, config: "DrawConfig", painter: QPainter):
        if self.grid_drawer:
            self.grid_drawer.draw(config, painter)

    def draw_labels(self, config: "DrawConfig", painter: QPainter):
        if self.label_drawer:
            self.label_drawer.draw(config, painter)


class GridDrawer(ABC):

    def __init__(self, axis: "AxisBase"):
        self.axis = axis
        self.data_source: Optional["AutoGeneratedAxisDataSource"] = None

    @abstractmethod
    def draw(self, config: "DrawConfig", painter: QPainter):
        raise NotImplementedError()


class LabelDrawer(ABC):

    def __init__(self, axis: "AxisBase"):
        self.axis = axis
        self.data_source: Optional["AxisDataSource"] = None

    @abstractmethod
    def draw(self, config: "DrawConfig", painter: QPainter):
        raise NotImplementedError()


class AxisDataSource(DataSource):

    def append_by_sequence(self, xs: List[float], align: "Alignment", item: List[T]):
        raise NotImplementedError()


class AutoGeneratedAxisDataSource(AxisDataSource):

    @abstractmethod
    def append_by_index(self, x: float, align: "Alignment" = Alignment.BEFORE):
        raise NotImplementedError()

    def append_by_sequence(self, xs: List[float], align: "Alignment", item: List[T]):
        """Don't need this method for this class at all."""
        pass

    def append_by_index_sequence(
        self, xs: List[float], align: "Alignment" = Alignment.BEFORE
    ):
        for x in xs:
            self.append_by_index(x, align)


class LineGridDataSource(AutoGeneratedAxisDataSource):
    """
    todo: add tail_length?
    """

    def append_by_index(self, x: float, align: "Alignment" = Alignment.BEFORE):
        self.append(x)


class LineGridDrawer(GridDrawer, ABC):

    def __init__(self, axis: "AxisBase"):
        super().__init__(axis)
        self.grid_color = QPalette().color(QPalette.Dark)
        self.data_source = LineGridDataSource()

    def draw(self, config: "DrawConfig", painter: QPainter):
        painter.setPen(QPen(QColor(self.grid_color)))
        if self.axis.orientation is Orientation.HORIZONTAL:
            self.draw_x(config, painter)
        else:
            self.draw_y(config, painter)

    def draw_x(self, config: "DrawConfig", painter: QPainter):
        drawing_cache = config.drawing_cache
        grid_top = drawing_cache.plot_area.top()
        grid_bottom = drawing_cache.plot_area.bottom()
        # for grid in self.data_source:
        # ui_x = drawing_cache.drawer_x_to_ui(grid.value)
        for value in self.data_source:
            ui_x = drawing_cache.drawer_x_to_ui(value)
            top_point = QPointF(ui_x, grid_top)
            # bottom_point = QPointF(ui_x, grid_bottom + grid.tail_length)
            bottom_point = QPointF(ui_x, grid_bottom)
            painter.drawLine(top_point, bottom_point)

    def draw_y(self, config: "DrawConfig", painter: QPainter):
        painter.setPen(QPen(QColor(self.grid_color)))
        drawing_cache = config.drawing_cache

        grid_left = drawing_cache.plot_area.left() - 1
        grid_right = drawing_cache.plot_area.right()

        # for grid in self.data_source:
        # ui_y = drawing_cache.drawer_y_to_ui(grid.value)
        # left_point = QPointF(grid_left - grid.tail_length, ui_y)
        for value in self.data_source:
            ui_y = drawing_cache.drawer_y_to_ui(value)
            left_point = QPointF(grid_left, ui_y)
            right_point = QPointF(grid_right, ui_y)
            painter.drawLine(left_point, right_point)


TEXT_FLAG = Qt.AlignLeft | Qt.AlignTop | Qt.TextWordWrap


@dataclass()
class TextLabelInfo:
    value: float
    text: str
    align: Alignment


class TextLabelDataSource(AxisDataSource):

    def append_by_sequence(self, xs: List[float], align: "Alignment", item: List[str]):
        for x, item in zip(xs, item):
            self.append(TextLabelInfo(x, item, align))


class DateTimeDataSource(AxisDataSource):

    def __init__(self, format: str = None):
        super().__init__()
        if format is None:
            format = "%Y-%m-%d"
        self.format = format

    def append_by_sequence(
        self, xs: List[float], align: "Alignment", dts: List[datetime]
    ):
        for x, dt in zip(xs, dts):
            self.append(TextLabelInfo(x, dt.strftime(self.format), align))


class ValueLabelDataSource(AutoGeneratedAxisDataSource):

    def __init__(self, format: str = None):
        super().__init__()
        if format is None:
            format = "%.2f"
        self.format = format

        self.data_list: List["float"] = []

    def append_by_index(self, x: float, align: "Alignment" = Alignment.BEFORE):
        self.append(TextLabelInfo(x, self.format % x, align))


class CandleLabelDataSource(AutoGeneratedAxisDataSource, DateTimeDataSource):

    def __init__(self, candle_data_source: CandleDataSource, format: str = None):
        super().__init__()
        DateTimeDataSource.__init__(self, format)
        self.candle_data_source: CandleDataSource = candle_data_source

    def append_by_index(self, x: int, align: "Alignment" = Alignment.BEFORE):
        try:
            data = self.candle_data_source[int(x)]
            self.append(TextLabelInfo(x, data.datetime.strftime(self.format), align))
        except IndexError:
            pass


class TextLabelDrawer(LabelDrawer, ABC):

    def __init__(self, axis: "AxisBase"):
        super().__init__(axis)
        palette = QPalette()
        self.label_color = palette.color(QPalette.Foreground)
        self.label_font = QFont()
        self.data_source = TextLabelDataSource()

    def draw(self, config: "DrawConfig", painter: QPainter):
        painter.setPen(QPen(QColor(self.label_color)))
        painter.setFont(self.label_font)
        if self.axis.orientation is Orientation.HORIZONTAL:
            self.draw_x(config, painter)
        else:
            self.draw_y(config, painter)

    def draw_x(self, config: "DrawConfig", painter: QPainter):
        drawing_cache = config.drawing_cache
        text_top = (
            drawing_cache.plot_area.bottom() + 1 + self.axis.label_spacing_to_plot_area
        )

        for text_info in self.data_source:  # type: TextLabelInfo
            ui_x = drawing_cache.drawer_x_to_ui(text_info.value)
            text = text_info.text
            rect = painter.boundingRect(0, 0, 1000, 1000, TEXT_FLAG, text)
            text_width = rect.height()

            align = text_info.align
            if align is Alignment.BEFORE:
                pos = QRectF(ui_x - text_width, text_top, rect.width(), rect.height())
            elif align is Alignment.MID:
                pos = QRectF(
                    ui_x - text_width / 2, text_top, rect.width(), rect.height()
                )
            else:
                pos = QRectF(ui_x, text_top, rect.width(), rect.height())
            painter.drawText(pos, text)

    def draw_y(self, config: "DrawConfig", painter: QPainter):
        drawing_cache = config.drawing_cache

        label_right = (
            drawing_cache.plot_area.left() - 1 - self.axis.label_spacing_to_plot_area
        )

        for text_info in self.data_source:  # type: TextLabelInfo
            ui_y = drawing_cache.drawer_y_to_ui(text_info.value)
            text = text_info.text
            rect: QRectF = painter.boundingRect(0, 0, 1000, 1000, TEXT_FLAG, text)
            label_width = rect.width()
            label_height = rect.height()

            align = text_info.align
            if align is Alignment.BEFORE:
                pos = QRectF(
                    label_right - label_width,
                    ui_y + label_height,
                    rect.width(),
                    rect.height(),
                )
            elif align is Alignment.MID:
                pos = QRectF(
                    label_right - label_width,
                    ui_y - label_height / 2,
                    rect.width(),
                    rect.height(),
                )
            else:
                pos = QRectF(
                    label_right - label_width,
                    ui_y - label_height,
                    rect.width(),
                    rect.height(),
                )
            painter.drawText(pos, text)


class ValueSequenceGenerator:

    def __init__(self, axis: "AxisBase", count: int):
        self.axis = axis
        self.count = count

    def prepare(self, config: "DrawConfig", painter: "QPainter") -> List[float]:
        orientation = self.axis.orientation
        if orientation is Orientation.HORIZONTAL:
            begin, end = config.begin, config.end
        else:
            begin, end = config.y_low, config.y_high

        step = (end - begin) / self.count

        if orientation is Orientation.VERTICAL:
            begin += (
                step
            )  # skip the lowest tick which is useless & can never be fully printed
        return [value for value in _generate_sequence(begin, end, step)]


class ValueAxis(AxisBase):

    def __init__(self, orientation: "Orientation"):
        super().__init__(orientation)
        self.format: str = "%.2f"
        self.label_count = 10

        self.grid_drawer = LineGridDrawer(self)
        self.label_drawer = TextLabelDrawer(self)

        self.label_data_source = ValueLabelDataSource()
        self.label_drawer.data_source = self.label_data_source

    def prepare_draw_grids(self, config: "DrawConfig", painter: "QPainter") -> None:
        seq = ValueSequenceGenerator(self, self.label_count).prepare(config, painter)
        ds = self.grid_drawer.data_source
        ds.clear()
        ds.append_by_index_sequence(seq, Alignment.MID)

    def prepare_draw_labels(self, config: "DrawConfig", painter: "QPainter") -> None:
        seq = ValueSequenceGenerator(self, self.label_count).prepare(config, painter)
        ds: ValueLabelDataSource = self.label_data_source
        ds.clear()
        ds.append_by_index_sequence(seq, Alignment.MID)


class ValueAxisX(ValueAxis):

    def __init__(self):
        super().__init__(Orientation.HORIZONTAL)


class ValueAxisY(ValueAxis):

    def __init__(self):
        super().__init__(Orientation.VERTICAL)


class BarAxis(ValueAxis):

    def __init__(self, orientation: "Orientation"):
        super().__init__(orientation)
        self.format: str = "%.2f"
        self.label_count = 10

        self.grid_drawer = LineGridDrawer(self)
        self.label_drawer = TextLabelDrawer(self)

        self.label_data_source = ValueLabelDataSource()
        self.label_drawer.data_source = self.label_data_source

    def prepare_draw_grids(self, config: "DrawConfig", painter: "QPainter") -> None:
        seq = ValueSequenceGenerator(self, self.label_count + 1).prepare(
            config, painter
        )
        ds = self.grid_drawer.data_source
        ds.clear()
        ds.append_by_index_sequence(seq, Alignment.AFTER)

    def prepare_draw_labels(self, config: "DrawConfig", painter: "QPainter") -> None:
        seq = ValueSequenceGenerator(self, self.label_count + 1).prepare(
            config, painter
        )
        ds: ValueLabelDataSource = self.label_data_source
        ds.clear()
        ds.append_by_index_sequence(seq, Alignment.AFTER)


class BarAxisX(ValueAxis):

    def __init__(self):
        super().__init__(Orientation.HORIZONTAL)


class BarAxisY(ValueAxis):

    def __init__(self):
        super().__init__(Orientation.VERTICAL)


class CandleAxisX(AxisBase):

    def __init__(self, data_source: "CandleDataSource"):
        super().__init__(Orientation.HORIZONTAL)
        self.label_count = 5
        self.data_source: "CandleDataSource" = data_source
        self.format = "%Y-%m-%d"

        self.label_data_source = CandleLabelDataSource(data_source)
        self.label_drawer = TextLabelDrawer(self)
        self.label_drawer.data_source = self.label_data_source

    def prepare_draw_grids(self, config: "DrawConfig", painter: "QPainter") -> None:
        seq = ValueSequenceGenerator(self, self.label_count + 1).prepare(
            config, painter
        )
        ds = self.grid_drawer.data_source
        ds.clear()
        ds.append_by_index_sequence([int(i) + 0.5 for i in seq])

    def prepare_draw_labels(self, config: "DrawConfig", painter: "QPainter") -> None:
        seq = ValueSequenceGenerator(self, self.label_count + 1).prepare(
            config, painter
        )
        ds: CandleLabelDataSource = self.label_data_source
        ds.clear()
        ds.append_by_index_sequence([int(i) + 0.5 for i in seq], Alignment.AFTER)


def _generate_sequence(begin, end, step):
    """output a sequence between [start, end)"""
    i = begin
    while i < end:
        yield i
        i += step
